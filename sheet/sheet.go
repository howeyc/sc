package sheet

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"github.com/howeyc/sc/evaler"
	"github.com/howeyc/sc/sheet/align"
)

const (
	STARTING_COLUMN_WIDTH = 10
)

type ColumnFormat struct {
	width     int
	precision int
	ctype     int
}

type Sheet struct {
	Filename string

	SelectedCell  Address
	columnFormats map[string]ColumnFormat
	data          map[Address]*Cell

	maxRowForColumn map[string]int
	maxColumnForRow map[int]string

	clipboardRangeStart, clipboardRangeEnd string

	// display window
	startRow, startCol       int
	displayRows, displayCols int
}

func NewSheet(filename string) Sheet {
	s := Sheet{Filename: filename, SelectedCell: "A0", columnFormats: make(map[string]ColumnFormat), data: make(map[Address]*Cell)}

	// Load file
	if file, err := os.Open(filename); err == nil {
		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			line := scanner.Text()
			if strings.HasPrefix(line, "#") || len(line) < 1 {
				continue
			}
			words := strings.Split(line, " ")
			cmd := ""
			adrs := Address("")
			val := ""
			if len(words) >= 2 {
				cmd = words[0]
				adrs = Address(words[1])
			}
			if len(words) >= 4 {
				val = strings.Join(words[3:], " ")
			}
			if len(val) > 1 && val[0] == '"' {
				val = val[1 : len(val)-1]
			}
			switch cmd {
			case "leftstring":
				s.SetCell(adrs, NewCell(val, align.AlignLeft, true))
			case "rightstrng":
				s.SetCell(adrs, NewCell(val, align.AlignRight, true))
			case "label":
				s.SetCell(adrs, NewCell(val, align.AlignCenter, true))
			case "let":
				s.SetCell(adrs, NewCell(val, align.AlignRight, false))
			case "goto":
				s.SelectedCell = adrs
			case "format":
				width, _ := strconv.ParseInt(words[2], 10, 64)
				precision, _ := strconv.ParseInt(words[3], 10, 64)
				ctype, _ := strconv.ParseInt(words[4], 10, 64)
				s.columnFormats[adrs.ColumnHeader()] = ColumnFormat{width: int(width), precision: int(precision), ctype: int(ctype)}
			}
		}
	}

	return s
}

func (s *Sheet) writeFormats(w io.Writer) {
	for k, cFormat := range s.columnFormats {
		fmt.Fprintf(w, "format %s %d %d %d\n", k, cFormat.width, cFormat.precision, cFormat.ctype)
	}
}

func (s *Sheet) getPrecision(address Address) int {
	if cFormat, found := s.columnFormats[address.ColumnHeader()]; found {
		return cFormat.precision
	} else {
		return 2
	}
}

func (s *Sheet) DisplayFormat(address Address) string {
	if cFormat, found := s.columnFormats[address.ColumnHeader()]; found {
		return fmt.Sprintf("%d %d %d", cFormat.width, cFormat.precision, cFormat.ctype)
	} else {
		return fmt.Sprintf("%d %d %d", STARTING_COLUMN_WIDTH, 2, 0)
	}
}

func (s *Sheet) getColumnWidth(column string) int {
	if cFormat, found := s.columnFormats[column]; found {
		return cFormat.width
	} else {
		s.columnFormats[column] = ColumnFormat{width: STARTING_COLUMN_WIDTH, precision: 2, ctype: 0}
		return STARTING_COLUMN_WIDTH
	}
}

func (s *Sheet) increaseColumnWidth(column string) {
	if cFormat, found := s.columnFormats[column]; found {
		cFormat.width += 1
		s.columnFormats[column] = cFormat
	} else {
		s.columnFormats[column] = ColumnFormat{width: STARTING_COLUMN_WIDTH + 1, precision: 2, ctype: 0}
	}
}

func (s *Sheet) decreaseColumnWidth(column string) {
	if cFormat, found := s.columnFormats[column]; found {
		if cFormat.width > 1 {
			cFormat.width--
			s.columnFormats[column] = cFormat
		}
	} else {
		s.columnFormats[column] = ColumnFormat{width: STARTING_COLUMN_WIDTH - 1, precision: 2, ctype: 0}
	}
}

func (s *Sheet) ClearCell(address Address) {
	if cell, err := s.GetCell(address); err == nil {
		for forRef, _ := range cell.forwardRefs {
			if forCell, forErr := s.GetCell(forRef); forErr == nil {
				delete(forCell.backRefs, forRef)
			}
		}
	}
	delete(s.data, address)
}

func (s *Sheet) GetCell(address Address) (*Cell, error) {
	if cell, found := s.data[address]; found {
		return cell, nil
	} else if address == s.SelectedCell {
		return &Cell{}, nil
	}
	return nil, errors.New("Cell does not exist in spreadsheet.")
}

func (s *Sheet) SetCell(address Address, cell *Cell) {
	if currentCell, found := s.data[address]; found {
		cell.backRefs = currentCell.backRefs
	}
	if !cell.stringType {
		postfix := evaler.GetPostfix(cell.value)
		for _, token := range postfix {
			if evaler.IsCellAddr(token) {
				tokenAddr := Address(token)
				cell.forwardRefs[tokenAddr] = struct{}{}
				if tokCell, tokErr := s.GetCell(tokenAddr); tokErr == nil {
					tokCell.backRefs[address] = struct{}{}
				}
			}
		}
	}
	s.data[address] = cell

	// TODO: change to display current cell and all back references
	s.display()
}

func (s *Sheet) Save() error {
	if outfile, err := os.Create(s.Filename); err == nil {
		fmt.Fprintln(outfile, "# This data file was generated by Spreadsheet Calculator.")
		fmt.Fprintln(outfile, "# You almost certainly shouldn't edit it.")
		fmt.Fprintln(outfile, "")

		s.writeFormats(outfile)

		for addr, cell := range s.data {
			cell.write(outfile, string(addr))
		}
		fmt.Fprintf(outfile, "goto %s A0", s.SelectedCell)
		outfile.Close()
		return nil
	} else {
		return err
	}
}
